#Exo 1: Affichage de la table de verité et de la forme canonique d'une fonction logique

#Posons F(A,B,C)=(A.B)+((¬C)+(¬D))

ALGORITHME

 #Affichage de la table de verité de la fonctionF
 
Algorithme TableDeVeriteF
    Fonction calcul_F(A, B, C, D)
        retourner (A ET B) OU (NON C ET NON D)
    Fin

    Afficher "A   B   C   D   F(A,B,C)"
    
    Pour chaque valeur de A de Vrai à Faux
        Pour chaque valeur de B de Vrai à Faux
            Pour chaque valeur de C de Vrai à Faux
                Pour chaque valeur de D de Vrai à Faux
                    resultat_F <- calcul_F(A, B, C, D)
                    AFFICHER A, " ", B, " ", C, " ", D, " ", resultat_F
                Fin pour
            Fin pour
        Fin pour
    Fin pour
Fin algorithme

 #Affichage de la première et deuxième forme canonique de la fonctionF
Lire les variables booléennes A, B, C, D
Calculer les termes de la fonction logique :
   F1 = (A AND B)
   F2 = (NOT C) AND (NOT D)
Afficher la première forme canonique :
   F = F1 OR F2
Afficher la deuxième forme canonique :
   F = (A + B)(NOT C + NOT D)
   
PYTHON

 #Affichage de la table de verité de la fonctionF
 
# Définition de la fonction logique F
def calcul_F(A, B, C, D):
    return (A and B) or (not C and not D)

# Affichage de la table de vérité de la fonction F
print("A   B   C   D   F(A,B,C)")
for A in [True, False]:
    for B in [True, False]:
        for C in [True, False]:
            for D in [True, False]:
                resultat_F = calcul_F(A, B, C, D)
                print(A, " ", B, " ", C, " ", D, " ", resultat_F)

# Affichage des formes canoniques de la fonction F
print("\nAffichage de la première et deuxième forme canonique de la fonction F")
print("F1 = (A AND B)")
print("F2 = (NOT C) AND (NOT D)")
print("Première forme canonique : F = F1 OR F2")
print("Deuxième forme canonique : F = (A + B)(NOT C + NOT D)")


#Exo 2: Minimisation d'une fonction donné par la méthode de KARNAUGH

#Posons F(A,B,C)=(A.B.C)+(A.(¬B).C)+(A.B.(¬C))

ALGORITHME

Fonction Karnaugh_Minimisation_F(A, B, C)
   return (A and B and C) or (A and (¬B) and C) or (A and B and (¬C))
    Variables:
        tableau_karnaugh_A <- Tableau de Karnaugh pour le terme A.B.C
        tableau_karnaugh_B <- Tableau de Karnaugh pour le terme A.(¬B).C
        tableau_karnaugh_C <- Tableau de Karnaugh pour le terme A.B.(¬C)
        groupes_minimaux_A <- Liste vide pour stocker les groupes minimaux de A.B.C
        groupes_minimaux_B <- Liste vide pour stocker les groupes minimaux de A.(¬B).C
        groupes_minimaux_C <- Liste vide pour stocker les groupes minimaux de A.B.(¬C)
        expression_minimale <- Chaine de caractères pour stocker l'expression minimale

#Construction des tableaux de Karnaugh
    tableau_karnaugh_A <- Construction_Tableau_Karnaugh(Fonction_A.B.C)
    tableau_karnaugh_B <- Construction_Tableau_Karnaugh(Fonction_A.(¬B).C)
    tableau_karnaugh_C <- Construction_Tableau_Karnaugh(Fonction_A.B.(¬C))

#Identification des groupes minimaux pour chaque terme
    groupes_minimaux_A <- Minimisation_Karnaugh(tableau_karnaugh_A)
    groupes_minimaux_B <- Minimisation_Karnaugh(tableau_karnaugh_B)
    groupes_minimaux_C <- Minimisation_Karnaugh(tableau_karnaugh_C)

#Combinaison des groupes minimaux pour obtenir l'expression minimale
    Pour chaque groupe dans groupes_minimaux_A:
        expression_minimale <- expression_minimale + 'A' * nombre_de_variables(groupe) + ' + '
    Pour chaque groupe dans groupes_minimaux_B:
        expression_minimale <- expression_minimale + '(¬B)' * nombre_de_variables(groupe) + ' + '
    Pour chaque groupe dans groupes_minimaux_C:
        expression_minimale <- expression_minimale + '(¬C)' * nombre_de_variables(groupe) + ' + '
    Retourner expression_minimale

PTHON

def Minimisation_Karnaugh(F):
    # Créer un tableau de Karnaugh pour la fonction F
    karnaugh_table = [
        [0, 1, 3, 2],
        [4, 5, 7, 6],
        [12, 13, 15, 14],
        [8, 9, 11, 10]
    ]

    # Identifier les groupes de 1 dans le tableau de Karnaugh
    groupes = []
    for i in range(4):
        for j in range(4):
            if F[karnaugh_table[i][j]] == 1:
                groupes.append([(i, j)])

    # Fusionner les groupes adjacents
    merged_groups = []
    while groupes:
        group = groupes.pop(0)
        for other_group in groupes[:]:
            if are_adjacent(group, other_group):
                group.extend(other_group)
                groupes.remove(other_group)
        merged_groups.append(group)

    # Simplifier les groupes fusionnés autant que possible
    simplified_groups = []
    for group in merged_groups:
        simplified_group = simplify_group(group)
        simplified_groups.append(simplified_group)

    # Générer l'expression minimale en utilisant les groupes minimisés
    expression_minimale = generate_minimal_expression(simplified_groups)

    return expression_minimale

def are_adjacent(group1, group2):
    for cell1 in group1:
        for cell2 in group2:
            if abs(cell1[0] - cell2[0]) + abs(cell1[1] - cell2[1]) == 1:
                return True
    return False

def simplify_group(group):
    simplified_group = []
    for cell in group:
        simplified_group.append(chr(65 + cell[1]) + "'" * cell[0])
    return simplified_group

def generate_minimal_expression(groups):
    expression = ""
    for group in groups:
        expression += "(" + " + ".join(group) + ") "
    return expression[:-1]

# Test de l'algorithme avec la fonction logique F(A, B, C) = A'B'C' + A'B'C + AB'C + ABC
F = [1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1]
expression_minimale = Minimisation_Karnaugh(F)
print("Expression minimale pour F(A, B, C) =", expression_minimale)

